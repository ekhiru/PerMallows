{
    "contents" : "# -----------------------------------------\n# Author: Ekhine Irurozki\n#         University of the Basque Country\n# -----------------------------------------\n\n###################   GENERAL   ###################\n\n.CAYLEY.DISTANCE  <- 0\n.KENDALL.DISTANCE <- 1\n.HAMMING.DISTANCE <- 2\n.ULAM.DISTANCE    <- 3\n\n#' Generate every permutation of perm.length item\n#' \n#' This functions returns a matrix in thich each of rows\n#' is a different permutation of the specified number of items\n#'\n#' @param perm.length number of items in the permutation\n#' @param alert optional ask for confirmation when the number of permtuations to show is very large\n#' @return A collection of every permutation of the specified number of items\n#' @export\n#' @examples\n#' permutations.of(3)\n#' permutations.of(10)\npermutations.of <- function(perm.length, alert=TRUE){\n  if ( alert && perm.length > 9) {\n    cat(\"Do you really want to generate all \",factorial(perm.length),\" permutations? (Y/N)\")\n    answer = readline()\n    if ( answer != 'Y' ) return(\"Process cancelled\")\n  }\n  return (.permutations.all.recursive(c(), c(1:perm.length)))\n}\n\n.permutations.all.recursive <- function(vec1, vec2){\n  len <- length(vec2)\n  perms = matrix(NA, ncol=length(vec2)+length(vec1), nrow=0)\n  if(len == 0) return (aperm(as.matrix(vec1))) \n  else\n    for(i in 1:len)\n      perms <- rbind(perms, .permutations.all.recursive(c(vec1, vec2[i]), vec2[-i]))\n  return (perms)\n}\n\n.same.length.perms <- function(s1, s2 ){\n  return(is.permutation(s1) &&  is.permutation(s2) && length(s1) == length(s2))\n}\n\n#' Generate identity the permutation\n#'\n#' This function generates the identity permutation of a given number of items\n#'\n#' @param perm.length number of items in the permutation\n#' @return The identity permutation of the specified number of items\n#' @export\n#' @examples\n#' identity.permutation(3)\n#' identity.permutation(7)\nidentity.permutation<-function(perm.length){\n  return(c(1:perm.length));\n}\n\n#' Generate inverse permutation\n#'\n#' This function generates the inverse of a given permutation. If the input \n#' is a matrix of permutations, invert all the permutations in the input. \n#'\n#' @param perm a permutation or matrix of permutations\n#' @return The inverse permutation. \n#' If the input is a matrix,the matrix with the inverses\n#' @export\n#' @examples\n#' inverse.permutation(c(1,2,3,4))\n#' inverse.permutation(c(2,3,4,1))\n#' sample <- matrix(c(1,2,3, 4,1,4,3,2,1,2,4,3), nrow = 3, ncol = 4, byrow = TRUE)\n#' inverse.permutation(sample)\ninverse.permutation <- function(perm){\n  if (is.permutation(perm))\n    if (is.vector( perm ) ) \n      return (order(perm))\n    else if (is.matrix(perm))\n      return (t(apply(perm, MARGIN=1,FUN=order)))\n  stop(\"Error in the input parameters: the input must be a permutation or a matrix of permutations\")\n}\n\n#' Compose permutations\n#'\n#' This function composes two given permtuations. One of the arguments \n#' can be a collection of permutations, but not both at the same time. In this \n#' case, every permutation in the collection is composed with the \n#' other argument\n#'\n#' @param perm1 a permtuation or a collection of permutations\n#' @param perm2 a permtuation or a collection of permutations\n#' @return The composition of the permutations\n#' @export\n#' @examples\n#' compose(c(3,1,2,4), c(4,1,3,2))\ncompose <- function(perm1, perm2){\n  if (!is.permutation(perm1) || ! is.permutation(perm2))\n    stop(\"Check parameters\")\n  if(is.matrix(perm1) && is.matrix(perm2)) \n    stop(\"Both params can not be samples\\n\") \n  if(is.vector(perm1) && is.vector(perm2) && .same.length.perms(perm1, perm2)) \n    return (.compose.perms(perm1,perm2))\n  if(is.matrix(perm1) && dim(perm1)[2] == length(perm2) )\n    return (t(apply(perm1, MARGIN=1,FUN=function(x){.compose.perms(x,perm2)})))\n  if(is.matrix(perm2) && dim(perm2)[2] == length(perm1))\n    return (t(apply(perm2, MARGIN=1,FUN=function(x){.compose.perms(perm1,x)})))\n  stop (\"Check input parameters\")\n}\n\n.compose.perms <- function(s,p){\n  return(s[p])\n}\n\n#' Check if its argument is a permutation\n#'\n#' This function tests if the given argument is a permutation of the first \n#' n natural integers excluding the 0\n#'\n#' @param perm a vector (or a bidimensional matrix)\n#' @return TRUE iff perm is a valid permutation (or a matrix of valid permutations)\n#' @export\n#' @examples\n#' is.permutation(c(3,1,2,4))\n#' is.permutation(c(6,1,2,3))\n#' is.permutation(matrix(c(1,2,3, 4,1,4,3,2,1,2,4,3), nrow = 3, ncol = 4, byrow = TRUE))\nis.permutation <- function(perm){\n  if (is.vector(perm)) return (.is.permutation.one(perm))\n  else if (is.matrix(perm))\n    return(all(apply(perm, MARGIN=1, .is.permutation.one)))\n  else stop(\"Error in the input parameters: the input must be a permutation or a matrix of permutations\")\n}\n\n.is.permutation.one <- function(perm){\n  bid<-logical(length = length(perm)) #bid: logical vector, all false\n  lapply(X=perm, function(x){\n    bid[x] <<- TRUE\n  })\n  return(all(bid))\n}\n\n#' Read a text file with a collection of permtuations\n#'\n#' This function reads the text file in the specified path and \n#' checks if each row is a proper permutation\n#'\n#' @param path string with a path\n#' @return A collection of permutations in matrix form\n#' @export\n#' @examples\n#' path = system.file(\"test.txt\", package=\"PerMallows\")\n#' sample = read.permutation.file(path)\nread.permutation.file <- function(path){\n  sample = as.matrix( read.table(path, sep=\" \"))\n  if (! is.permutation(sample) )\n    stop(\"Not valid permtuations in the matrix\")\n  return(sample)\n}\n\n#' Convert rating to permutation\n#'\n#' This function is given a collection of ratings and converts each row to\n#' a permutation\n#'\n#' @param ratings a matrix in which each row is a vector of ratings of several items\n#' @return A matrix in which each row is the corresponding permutation of the items\n#' @export\n#' @examples\n#' order.ratings(c(0.1, 4, 0.5, -4))\norder.ratings <- function(ratings){\n  if (is.vector(ratings))\n    return (order(ratings))\n  return (t(apply(ratings, MARGIN=1, FUN=order)))\n  stop(\"The input parameter must be a vector\")\n}\n\n#' Random permutation\n#'\n#' Generate a collection of n permutations uniformly at random\n#'\n#' @param n optional number of permutations to generate\n#' @param perm.length length of the permutations generated\n#' @return A single permutation or a matrix with n rows, each being a permutation. \n#' Every permutation is drawn uniformly at random and has length perm.length\n#' @export\n#' @examples\n#' runif.permutation(1,5)\nrunif.permutation <- function(n=1 , perm.length){\n  x <- c(1:perm.length)\n  if ( n == 1 ) {\n    x <- .C(\"random_permutation\", as.integer(perm.length), as.integer(x))[[2]]\n    return (x)\n  }\n  return (t (replicate(n, .C(\"random_permutation\", as.integer(perm.length), as.integer(x))[[2]])))\n}\n\n#' Compute the frequency matrix\n#'\n#' Compute the first order marginal probability. In other words, given at least one \n#' permutation, calculate the proportion of them that have each item in each position\n#'\n#' @param perm a permutation or a collection of them\n#' @return A matrix with n rows and n columns with the proportion of the permutations \n#' in the input that have each item in each position\n#' @export\n#' @examples\n#' freq.matrix(c(1,3,2,4,5))\nfreq.matrix <- function(perm){\n  if( !is.permutation(perm) ) stop (\"Check parameters\")\n  if ( is.vector(perm) ) {\n    perm.length <- length(perm)\n    #mat <- matrix(0, perm.length, perm.length)\n    mat<-diag(perm.length)[,perm]\n  }else if (is.matrix(perm)){\n    perm.length <- dim(perm)[2]\n    mat <- matrix(0, perm.length, perm.length)\n    apply(X=perm, MARGIN=1, FUN=function(x){\n      #mat <<- mat + diag(perm.length)[,x]   # fast\n      for (i in 1:perm.length) mat[i,x[i]] <<- mat[i,x[i]] + 1 #low mem\n    })\n    mat = mat / dim(perm)[1]\n  }else stop(\"Check arguments\")\n  return (mat)\n}\n\n###################   PROBABILITY DISTRIBUTIONS   ###################\n\n#' Compute the marginal probability, GMM under the Hamming distance\n#' \n#' Compute the marginal probability, GMM under the Hamming distance, \n#' of a distance decomposition vector for which some positions are known and some are not\n#'\n#' @param h n dimensional distance decomposition vector where h_j = 0 means that $j$ is a fixed point, \n#' h_j = 1 means that $j$ is an unfixed point and otherwise $j$ is not known\n#' @param theta n dimensional distance decomposition vector with the dispersion parameters\n#' @return The marginal probability\n#' @export\n#' @examples\n#' marginal(c(1,0,1,NA,NA), c(0.1, 0.3, 0.7, 0.1, 1))\n#' marginal(c(NA,0,1,NA,NA,0), c(0.1, 0.3, 0.7, 0.1, 0.7, 1))\nmarginal <- function(h, theta){\n  if (length(h) != length(theta))\n    stop(\"Check the length of the h and theta vectors\")\n  res <- 0\n  h[is.na(h)] <- -1\n  res<-.C(\"marginals\", as.integer(length(h)), as.integer(.check.distance.name(\"hamming\")), as.integer(h),\n          as.numeric(theta), as.double(res))[5]\n  return (res[[1]]) \n}\n\n#' Compute the expected distance, MM under the Hamming distance\n#' \n#' Compute the expected distance in the MM under the Hamming distance\n#'\n#' @param theta real dispersion parameter\n#' @param perm.length length of the permutation in the considered model\n#' @param dist.name optional name of the distance used in the MM. One of: kendall (default), cayley, hamming, ulam\n#' @return The expected distance under the MM\n#' @export\n#' @examples\n#' expectation.mm( 1, 7, \"kendall\" )\n#' expectation.mm( 2, 5, \"cayley\" )\n#' expectation.mm( 2, 4, \"hamming\" )\n#' expectation.mm( 1, 6, \"ulam\" )\nexpectation.mm <- function(theta, perm.length,  dist.name=\"kendall\"){\n  dist_id = .check.distance.name(dist.name, FALSE)\n  expec <- rep(0,perm.length)\n  expec<-.C(\"expectation\",  as.integer(dist_id), as.integer(0), as.integer(perm.length), \n        as.double(theta),as.double(expec))[5]\n  return (expec[[1]][1]) \n}\n\n#' Compute the expected distance, GMM under the Hamming distance\n#' \n#' Compute the expected distance in the GMM under the Hamming distance\n#'\n#' @param theta n dimensional real vector with the dispersion parameters\n#' @return The expected distance decomposition vector under the GMM\n#' @param dist.name optional name of the distance used in the GMM. One of: kendall (default), cayley, hamming\n#' @export\n#' @examples\n#' expectation.gmm(c(0.38, 0.44, 0.1, 0.2, 1, 0.1))\n#' expectation.gmm(c(2, 2, 2, 2),\"cayley\")\n#' expectation.gmm(c(0.3, 0.1, 0.5, 0.1),\"hamming\")\nexpectation.gmm <- function (theta, dist.name=\"kendall\"){\n  dist_id = .check.distance.name(dist.name, TRUE)\n  if ( dist_id == .HAMMING.DISTANCE )  perm.length <- length(theta) \n  else  perm.length <- length(theta) + 1\n  expec <- rep(0,perm.length)\n  expec<-.C(\"expectation\",  as.integer(dist_id), as.integer(1), as.integer(perm.length), \n           as.double(theta),as.double(expec))[5]\n return (expec[[1]]) \n}\n\n.check.distance.name <- function(dist.name, for.gmm = FALSE){\n  if ( for.gmm ) err.msg = \"Choose one of these distances: Cayley, Kendall, Hamming\"\n  else err.msg = \"Choose one of these distances: Cayley, Kendall, Hamming, Ulam\"\n  \n  if      (dist.name == \"c\" || dist.name == \"cayley\"  || dist.name == \"Cayley\")  dist_id = .CAYLEY.DISTANCE\n  else if (dist.name == \"k\" || dist.name == \"Kendall\" || dist.name == \"kendall\") dist_id = .KENDALL.DISTANCE\n  else if (dist.name == \"h\" || dist.name == \"Hamming\" || dist.name == \"hamming\") dist_id = .HAMMING.DISTANCE\n  else if (dist.name == \"u\" || dist.name == \"Ulam\"    || dist.name == \"ulam\" &&  !for.gmm )    dist_id = .ULAM.DISTANCE\n  else stop(err.msg)\n  return (dist_id)\n}\n\n.check.theta.length.gmm <- function(dist_id, theta.length, perm.length){\n  if ( dist_id == 0 && ! ( theta.length == perm.length - 1))      \n    stop (\"Check Theta length, must be \", perm.length - 1, \".\")\n  else if ( dist_id == 1 && ! ( theta.length == perm.length - 1)) \n    stop (\"Check Theta length, must be \", perm.length - 1, \".\")\n  else if ( dist_id == 2 && ! ( theta.length == perm.length ))    \n    stop (\"Check Theta length, must be \", perm.length, \".\")\n  return (theta.length == 1)\n}\n\n#' Calculate the probability of a permutation in a MM \n#'\n#' Calculate the probability of a permutation sigma in a MM of center sigma0, \n#' dispersion parameter theta and under the specified distance\n#'\n#' @param perm permutation whose probability is asked for\n#' @param sigma0 optional central permuation of the MM, by default the identity\n#' @param theta dispersion parameter of the MM\n#' @param dist.name optional name of the distance used in the MM. One of: kendall (default), cayley, hamming, ulam\n#' @return The probability of sigma in the given MM\n#' @export\n#' @examples\n#' sample <- matrix(c(1,2,3, 4,1,4,3,2,1,2,4,3), nrow = 3, ncol = 4, byrow = TRUE)\n#' sig<-c(1,2,3,4)\n#' log.prob <- apply(sample,MARGIN=1,FUN=function(x){log(dmm(x,sig, 1,\"cayley\"))})\n#' sum(log.prob)\n#' dmm(c(1,3,2,4), theta=0.1)\n#' dmm(c(1,3,2,4), theta=0.1, dist.name=\"cayley\")\n#' dmm(c(1,3,2,4), theta=0.1, dist.name=\"hamming\")\n#' dmm(c(1,3,2,4), theta=0.1, dist.name=\"ulam\")\ndmm <- function(perm, sigma0=identity.permutation(length(perm)), theta, dist.name=\"kendall\"){\nif (!is.permutation(perm) || ! is.permutation(sigma0))\n    stop(\"Check parameters\")\n  dist_id       = .check.distance.name(dist.name)\n  if( length(theta) == 1 ) theta = rep( theta, length(perm)  )\n  else stop (\"This function is for the MM (just one dispersion parameters)\")\n  return (.proba(perm, sigma0, theta, dist_id))\n}\n\n#' Calculate the probability of a permutation in a GMM \n#'\n#' Calculate the probability of a permutation sigma in a GMM of center sigma0, \n#' dispersion parameter theta and under the specified distance\n#'\n#' @param perm permutation whose probability wants to be known\n#' @param sigma0 central permuation of the GMM, by default the identity\n#' @param theta vector dispersion parameter of the GMM\n#' @param dist.name optional name of the distance used in the GMM. One of: kendall (default), cayley, hamming\n#' @return The probability of sigma in the given GMM\n#' @export\n#' @examples\n#' sample <- matrix(c(1,2,3,4, 1,4,3,2, 1,2,4,3), nrow = 3, ncol = 4, byrow = TRUE)\n#' sig <- c(1,2,3,4)\n#' th <- c(0.1, 0.2, 0.3,1)\n#' log.prob <- apply(sample,MARGIN=1,FUN=function(x){log(dgmm(x,sig, th, \"hamming\"))})\n#' sum(log.prob)\n#' dgmm (c(1,2,3,4), theta=c(1,1,1))\n#' dgmm (c(1,2,3,4), theta=c(1,1,1), dist.name=\"cayley\")\ndgmm <- function(perm, sigma0=identity.permutation(length(perm)), theta, dist.name=\"kendall\"){\n  if (!is.permutation(perm) || ! is.permutation(sigma0))\n    stop(\"Check parameters\")\n  dist_id       = .check.distance.name(dist.name, TRUE)\n  mallows.model = .check.theta.length.gmm(dist_id, length(theta), length(perm)  )\n  return (.proba(perm, sigma0, theta, dist_id))\n}\n\n.proba <- function (perm, sigma0, theta, dist_id){\n    res = -1;\n  if(.same.length.perms(perm,sigma0) ){\n      res<-.C(\"probability\", as.integer(dist_id), as.integer(length(perm)),as.integer(perm),\n                as.integer(sigma0), as.numeric(theta), as.double(res))[6]\n    }else stop (\"The permutations must have the same number of items\")\n    return( unlist(res) );\n}\n\n#' Sample a Mallows Model\n#'\n#' Generate a sample of n permutations from a Mallows Model (MM). \n#'\n#' @param n the number of permutations to be generated\n#' @param sigma0 central permuation of the MM\n#' @param theta dispersion parameter of the MM\n#' @param dist.name optional name of the distance used in the MM. One of: kendall (default), cayley, hamming, ulam\n#' @param sampling.method optional name of the sampling algorithm. One of: distances, multistage, gibbs (default)\n#' @param disk optional can only be true if using the Distances sampling algorithm for generating under the Ulam distance.\n#' Insted of generating the whole set of SYT and count of permutations per distance, it loads the info from a file in the disk\n#' @return A matrix contaning a sample of permutations from the specified ditribution\n#' @export\n#' @examples\n#' rmm(2,c(1,2,3,4,5),1,\"kendall\", \"distances\")\n#' rmm(2,c(1,2,3,4,5),1,\"cayley\", \"distances\")\n#' rmm(2,c(1,2,3,4,5),1,\"hamming\", \"distances\")\n#' rmm(2,c(1,2,3,4,5),1,\"ulam\", \"distances\")\n#' rmm(2,c(1,2,3,4,5),1,\"kendall\", \"multistage\")\n#' rmm(2,c(1,2,3,4,5),1,\"cayley\", \"multistage\")\nrmm <- function(n, sigma0, theta, dist.name=\"kendall\", sampling.method=\"distances\", disk=FALSE){\n  if (! is.permutation(sigma0))\n    stop(\"Check parameters\")\n  num.perms <- n\n  perm.length <- length(sigma0)\n  if(length(theta) != 1 ) stop(\"Theta must be one real number\") \n  dist_id       = .check.distance.name(dist.name)\n  \n  if      ( sampling.method == \"distances\"  || sampling.method == \"distances\")  algorithm_id = 0\n  else if ( sampling.method == \"multistage\" || sampling.method == \"multistage\") algorithm_id = 1\n  else if ( sampling.method == \"gibbs\"      || sampling.method == \"gibbs\")      algorithm_id = 2\n  else stop(\"Choose one of these sampling.method: distances, multistage, gibbs\")\n\n  if ( disk ){\n    if ( algorithm_id == 0 && dist_id == 3){\n      dist_id = 4\n      if ( ! file.exists(paste('permus_per_dist_',perm.length, sep=\"\")) )\n        stop(\"Generate first the files. Try: \",paste ('generate.aux.files(',perm.length, ')'))\n    }\n    else stop (\"Geneneration form disk can only be used with Ulam and Distances sampling method\")\n  }\n  \n  if( dist_id == 3 && algorithm_id != 0 ) \n    stop (\"No Gibbs or multistage algorithm for the Ulam distance, choose distances\")\n  \n  if (algorithm_id == 0)\n    sam <- .Call(\"distances_sampling\", dist_id, perm.length, num.perms, theta)\n  else if (algorithm_id == 1 || algorithm_id == 2 ){\n    theta <- rep(theta,perm.length-1)\n    sam <- .Call(\"sampling_multi_gibbs_cayley\",dist_id,  perm.length, num.perms, theta, 0, algorithm_id)\n  }else stop(\"Choose one of these algorithms: Distances, Gibbs, Multistage\")\n  if(!all(sigma0 == identity.permutation(perm.length)) ) \n    sam <- compose(sam, sigma0)\n  return(sam)\n}\n\n#' Sample a Generalized Mallows Model\n#'\n#' Generate a sample of n permutations from a Generalized Mallows Model (GMM). \n#'\n#' @param n the number of permutations to be generated\n#' @param sigma0 central permuation of the GMM\n#' @param theta dispersion parameter vector of the GMM\n#' @param dist.name optional used name of the distance used in the GMM. One of: kendall (default), cayley, hamming\n#' @param sampling.method optional name of the sampling algorithm. One of: multistage, gibbs (default)\n#' @return A matrix contaning a sample of permutations from the specified ditribution\n#' @export\n#' @examples\n#' rgmm(2,c(1,2,3,4,5),c(1,1,1,1),\"kendall\", \"multistage\")\n#' rgmm(2,c(1,2,3,4,5),c(1,1,1,1),\"cayley\", \"multistage\")\n#' rgmm(2,c(1,2,3,4,5),c(1,1,1,1,1),\"hamming\", \"multistage\")\n#' rgmm(2,c(1,2,3,4,5),c(1,1,1,1),\"cayley\", \"gibbs\")\n#' rgmm(2,c(1,2,3,4,5),c(1,1,1,1,1),\"hamming\", \"gibbs\")\nrgmm <- function(n, sigma0, theta, dist.name=\"kendall\", sampling.method=\"gibbs\"){\n  if (! is.permutation(sigma0))\n    stop(\"Check parameters\")\n  num.perms <- n\n  perm.length <- length(sigma0)\n  theta.length <- length(theta)\n  \n  dist_id       = .check.distance.name(dist.name, TRUE)\n  mallows.model = .check.theta.length.gmm(dist_id, theta.length, perm.length)\n  \n  if ( sampling.method == \"multistage\" || sampling.method == \"multistage\")  algorithm_id = 1\n  else if ( sampling.method == \"gibbs\"      || sampling.method == \"gibbs\")  algorithm_id = 2\n  else stop(\"Choose one of these sampling.method: Multistage, Gibbs\")\n  \n  sam <- .Call(\"sampling_multi_gibbs_cayley\",dist_id, perm.length, num.perms, theta, 1, algorithm_id);\n  #browser()\n  if(!all(sigma0 == identity.permutation(perm.length)) ) \n    sam <- compose(sam, sigma0)\n  return(sam)\n}\n\n#' Learn a Mallows Model\n#'\n#' Learn the parameter of the distribution of a sample of n permutations \n#' comming from a Mallows Model (MM). \n#'\n#' @param sample the matrix with the permutations to estimate\n#' @param sigma_0_ini optional the initial guess for the consensus permutation\n#' @param dist.name optional the name of the distance used by the model. One of: kendall (default), cayley, hamming, ulam\n#' @param estimation optional select the approximated or the exact. One of: approx, exact\n#' @param disk optional can only be true if estimating a MM under the Ulam distance.\n#' Insted of generating the whole set of SYT and count of permutations per distance, it loads the info from a file in the disk\n#' @return A list with the parameters of the estimated distribution: the\n#' mode and the dispersion parameter\n#' @export\n#' @examples\n#' sample <- matrix(c(1,2,3,4, 1,4,3,2, 1,2,4,3), nrow = 3, ncol = 4, byrow = TRUE)\n#' lmm(sample, dist.name=\"kendall\", estimation=\"approx\")\n#' lmm(sample, dist.name=\"cayley\", estimation=\"approx\")\n#' lmm(sample, dist.name=\"cayley\", estimation=\"exact\")\n#' lmm(sample, dist.name=\"hamming\", estimation=\"exact\")\n#' lmm(sample, dist.name=\"ulam\", estimation=\"approx\")\nlmm <- function(sample, sigma_0_ini =identity.permutation(dim(sample)[2]), dist.name=\"kendall\", estimation=\"approx\", disk=FALSE){\n  if (! is.permutation(sample)) stop(\"Check parameters\")\n  if(! .same.length.perms(sample[1,],sigma_0_ini)) \n    stop (\"Permutation sigma_0_ini must have the same number of items as the permutations in the sample\")\n  num.perms <- dim(sample)[1]\n  perm.length <- dim(sample)[2]\n  dist_id = .check.distance.name(dist.name)\n  \n  if(estimation == \"Exact\" || estimation == \"exact\") estim_var = 0\n  else if(estimation == \"Approx\" || estimation == \"approx\") estim_var = 1\n  else stop(\"Choose one of these estimations: approx, exact\")\n  \n  if ( disk ){\n    if ( dist_id == 3){\n      dist_id = 4\n      if ( ! file.exists(paste('permus_per_dist_',perm.length, sep=\"\")) )\n        stop(\"Generate first the files. Try: \",paste ('generate.aux.files(',perm.length, ')'))\n    }\n    else stop (\"Estimation form disk can only be used with Ulam distance\")\n  }\n  \n  if (estim_var == 1 && dist_id == .HAMMING.DISTANCE ) stop (\"No approx learning for the Hamming MM, try exact\")\n  if (estim_var == 0 && (dist_id != .CAYLEY.DISTANCE && dist_id != .HAMMING.DISTANCE) ) \n    stop (\"Exact learning only for cayley and Hamming\")\n  sigma0 <- .Call(\"consensus\", dist_id, sample, 0, estim_var, sigma_0_ini)  \n  \n  the <- .Call(\"estimate_theta\", dist_id, perm.length, num.perms, sigma0, sample, 0)\n  return(list(mode = sigma0, theta = the[1]));\n}\n\n#' Learn a Generalized Mallows Model\n#'\n#' Learn the parameter of the distribution of a sample of n permutations \n#' comming from a Generalized Mallows Model (GMM). \n#'\n#' @param sample the matrix with the permutations to estimate\n#' @param sigma_0_ini optional the initial guess for the consensus permutation\n#' @param dist.name optional name of the distance used by the GMM. One of: kendall (default), cayley, hamming\n#' @param estimation optional select the approximated or the exact. One of: approx, exact\n#' @return A list with the parameters of the estimated distribution: the\n#' mode and the dispersion parameter vector\n#' @export\n#' @examples\n#' sample <- matrix(c(1,2,3,4, 1,4,3,2, 1,2,4,3), nrow = 3, ncol = 4, byrow = TRUE)\n#' lgmm(sample, dist.name=\"kendall\", estimation=\"approx\")\n#' lgmm(sample, dist.name=\"cayley\", estimation=\"approx\")\n#' lgmm(sample, dist.name=\"cayley\", estimation=\"exact\")\n#' lgmm(sample, dist.name=\"hamming\", estimation=\"approx\")\nlgmm <- function(sample, sigma_0_ini =identity.permutation(dim(sample)[2]), dist.name=\"kendall\", estimation=\"approx\"){\n  if (! is.permutation(sample)) stop(\"Check parameters\")\n  if(! .same.length.perms(sample[1,], sigma_0_ini)) \n    stop (\"Permutation sigma_0_ini must have the same number of items as the permutations in the sample\")\n  num.perms <- dim(sample)[1]\n  perm.length <- dim(sample)[2]\n  dist_id = .check.distance.name(dist.name , TRUE)\n  \n  if(estimation == \"Exact\" || estimation == \"exact\") estim_var = 0\n  else if(estimation == \"Approx\" || estimation == \"approx\") estim_var = 1\n  else stop(\"Choose one of these estimations: approx, exact\")\n  \n  if (estim_var == 0 && dist_id != .CAYLEY.DISTANCE ) \n    stop (\"Exact leraning only for Cayley\")\n  sigma0 <- .Call(\"consensus\", dist_id, sample, 1, estim_var, sigma_0_ini)\n  the <- .Call(\"estimate_theta\", dist_id, perm.length, num.perms, sigma0, sample, 1)\n  if ( dist_id == 2 ) theta.len = perm.length\n  else  theta.len = perm.length - 1\n  return(list(mode = sigma0, theta = the[1:theta.len]));\n}\n\n#' MLE for theta - Mallows Model\n#'\n#' Compute the MLE for the dispersion parameter (theta) given a sample of n permutations\n#' and a central permutation\n#'\n#' @param sample the matrix with the permutations to estimate\n#' @param sigma_0 optional the consensus permutation. If not given it is assumed to be the identity permutation\n#' @param dist.name optional the name of the distance used by the model. One of: kendall (default), cayley, hamming, ulam\n#' @param disk optional can only be true if estimating a MM under the Ulam distance.\n#' Insted of generating the whole set of SYT and count of permutations per distance, it loads the info from a file in the disk\n#' @return The MLE for the dispersion parameter\n#' @export\n#' @examples\n#' sample <- matrix(c(1,2,3,4, 1,4,3,2, 1,2,4,3), nrow = 3, ncol = 4, byrow = TRUE)\n#' lmm.theta(sample, dist.name=\"kendall\")\n#' lmm.theta(sample, dist.name=\"cayley\")\n#' lmm.theta(sample, dist.name=\"cayley\", sigma_0=c(1,4,3,2))\n#' lmm.theta(sample, dist.name=\"hamming\")\n#' lmm.theta(sample, dist.name=\"ulam\")\nlmm.theta <- function(sample, sigma_0 =identity.permutation(dim(sample)[2]), dist.name=\"kendall\",\n                         disk=FALSE){\n  if (! is.permutation(sample))  stop(\"Check parameters\")\n  if(! .same.length.perms(sample[1,], sigma_0)) \n    stop (\"Permutation sigma_0 must have the same number of items as the permutations in the sample\")\n  num.perms <- dim(sample)[1]\n  perm.length <- dim(sample)[2]\n  dist_id = .check.distance.name(dist.name)\n  \n  if ( disk ){\n    if ( dist_id == 3){\n      dist_id = 4\n      if ( ! file.exists(paste('permus_per_dist_',perm.length, sep=\"\")) )\n        stop(\"Generate first the files. Try: \",paste ('generate.aux.files(',perm.length, ')'))\n    }\n    else stop (\"Estimation form disk can only be used with Ulam distance\")\n  }\n  \n  the <- .Call(\"estimate_theta\", dist_id, perm.length, num.perms, sigma_0, sample, 0)\n  return(theta = the[1]);\n}\n\n#' MLE for theta - Generalized Mallows Model\n#'\n#' Compute the MLE for the dispersion parameter (theta) given a sample of n permutations\n#' and a central permutation\n#'\n#' @param sample the matrix with the permutations to estimate\n#' @param sigma_0 optional the initial guess for the consensus permutation. If not given it is assumed to be the identity permutation\n#' @param dist.name optional name of the distance used by the GMM. One of: kendall (default), cayley, hamming\n#' @return The MLE for the dispersion parameter\n#' @export\n#' @examples\n#' sample <- matrix(c(1,2,3,4, 1,4,3,2, 1,2,4,3), nrow = 3, ncol = 4, byrow = TRUE)\n#' lgmm.theta(sample, dist.name=\"kendall\")\n#' lgmm.theta(sample, dist.name=\"cayley\")\n#' lgmm.theta(sample, dist.name=\"cayley\", sigma_0=c(1,4,3,2))\n#' lgmm.theta(sample, dist.name=\"hamming\")\nlgmm.theta <- function(sample, sigma_0 =identity.permutation(dim(sample)[2]), dist.name=\"kendall\"){\n  if (! is.permutation(sample))  stop(\"Check parameters\")\n  if(! .same.length.perms(sample[1,], sigma_0)) \n    stop (\"Permutation sigma_0 must have the same number of items as the permutations in the sample\")\n  num.perms <- dim(sample)[1]\n  perm.length <- dim(sample)[2]\n  dist_id = .check.distance.name(dist.name , TRUE)\n  \n  the <- .Call(\"estimate_theta\", dist_id, perm.length, num.perms, sigma_0, sample, 1)\n  if ( dist_id == 2 ) theta.len = perm.length\n  else  theta.len = perm.length - 1\n  return(theta = the[1:theta.len]);\n}\n\n#' Generates the files for Ulam\n#'\n#' Generates files for Ulam which are aimed to accelelrate the processes of counting \n#' the number of permutations at ech distance, sampling and learning IFF these operations\n#' are going to be computted more than once\n#'\n#' @param perm.length number of items in the permutations\n#' @return Nothing. Only writes in the current folder the axiliary files\n#' @export\n#' @examples\n#' generate.aux.files(4)\ngenerate.aux.files <- function(perm.length){\n  .C(\"save_counts_to_files\", as.integer(perm.length))\n}\n\n###################   DISTANCE RELATED   ###################\n\n#' Swap two items of a permutation\n#'\n#' Given a permutation and two position, swap both positions\n#'\n#' @param perm a permutation\n#' @param i position of the permutation\n#' @param j position of the permutation\n#' @return The permutation in the input in which the two speicfied items have been swapped\n#' @export\n#' @examples\n#' swap(c(1,2,3,4,5),2,5)\nswap <- function(perm, i, j){\n  if (!.is.permutation.one(perm)) stop(\"The input parameter perm must be a valid permutation\")\n  n <- length(perm)\n  if ( i < 1 || i > n || j < 1 || j > n ) stop (\"Swap only possible at positions 1..\",n)\n  if (i == j ) stop (\"Set different values for i and j\")\n  aux <- perm[i]\n  perm[i] <- perm[j]\n  perm[j] <- aux\n  return (perm)\n}\n\n#' Inversion operator\n#'\n#' Given a permutation and a position, swap positions i and i+1\n#'\n#' @param perm a permutation\n#' @param i position of the permutation\n#' @return The permutation in the input with an inversion at the specified position\n#' @export\n#' @examples\n#' inversion.at(c(1,2,3,4,5),2)\ninversion.at <- function(perm, i){\n  if (!.is.permutation.one(perm)) stop(\"The input parameter perm must be a valid permutation\")\n  n <- length(perm)\n  if ( i < 1 || i > n-1 ) stop (\"Inversion only possible at positions 1..\",n-1)\n  aux <- perm[i]\n  perm[ i ] <- perm[i+1]\n  perm[ i + 1 ] <- aux\n  return (perm)\n}\n\n#' Insert operator\n#'\n#' Given a permutation and two positions i, j, move item in position i to position j\n#'\n#' @param perm a permutation\n#' @param i position of the permutation\n#' @param j position of the permutation\n#' @return The permutation in the input in which th eoperation has been applied\n#' @export\n#' @examples\n#' insert.at(c(1,2,3,4,5),5,2)\n#' insert.at(c(1,2,3,4,5),2,5)\ninsert.at <- function(perm, i, j){\n  #remove item at position i and place it after the j-th position \n  if (!.is.permutation.one(perm)) stop(\"The input parameter perm must be a valid permutation\")\n  n <- length(perm)\n  if(i<1 || i>n || j < 0 || j >n)  stop (\"Insertion only possible at positions 1..\",n)\n  item <- perm[ i ]\n  mod  <- perm[-i ]\n  if(i<j) j <- j-1\n  if(j<1)\n    sigma <- c(item, mod[(j+1):length(mod)])\n  else if((j+1)>length(mod)) \n    sigma <- c(mod[1:j], item)\n  else \n    sigma <- c(mod[1:j], item, mod[(j+1):length(mod)])\n  return (sigma)\n}\n\n#' Decompose a permutation in a set of cycles\n#'\n#' Factor a given a permutation in the set of independent cycles\n#'\n#' @param perm a permutation\n#' @return The permutation in the input in which the operation has been applied\n#' @export\n#' @examples\n#' permutation2cycles(c(1,5,2,3,4))\npermutation2cycles <- function (perm){\n  if (!is.vector(perm) || !is.permutation(perm))\n    stop(\"Check parameters\")\n  s <- perm\n  perm.length <- length(s)\n  cont <- 0\n  cont_cycle <- 0 \n  while (cont < perm.length){\n    cont_cycle <- cont_cycle + 1\n    current <- 1\n    while ( s[ current ] == 0 ) current <- current + 1\n    if(cont_cycle == 1) cycles <- list (c(s[ current ]))\n    else cycles <- append(cycles, c(s[ current ]))\n    repeat{\n      cont <- cont + 1\n      next_i <- s[ current ]\n      s[ current ] <- 0\n      current <- next_i\n      if( s[ current ] != 0)\n        cycles[[cont_cycle]] = c(cycles[[cont_cycle]],  s[ current ])\n      else {\n        break\n      }\n    }\n  }\n  return (cycles)\n}\n\n#' Friendly display the cycles\n#'\n#' Given a list with the cycles of a permutation, displays them in the standard cycle notation\n#'\n#' @param cy a list with the set of cycles\n#' @export\n#' @examples\n#' cycle2str(permutation2cycles(c(1,5,2,3,4)))\ncycle2str <- function(cy){\n  invisible(lapply(cy, FUN=function(x){\n    cat(\"(\") \n    cat(x)\n    cat(\")\")\n    return()\n  }))\n}\n#' Get the permutation given the cycles\n#'\n#' Get the permutation as a vector given the set of cycles in which it factorizes\n#'\n#' @param cycles a list with the set of disjoint cycles\n#' @return The permutation in vector notation\n#' @export\n#' @examples\n#' cycles2permutation(permutation2cycles(c(1,5,2,3,4)))\ncycles2permutation <- function(cycles){\n  num_cycles <- length(cycles)\n  perm <- c()\n  for(i in 1:num_cycles){\n    cycle_len <- length(cycles[[i]])\n    for(j in 1:cycle_len){\n      if ( j== cycle_len) perm[cycles[[i]][j]]=cycles[[i]][1]\n      else perm[cycles[[i]][j]]=cycles[[i]][j+1]\n    }\n  }\n  if (!.is.permutation.one(perm)) stop(\"The cycles do not correspond to a valid permutation\")\n  return (perm)\n}\n\n#' Compute the distance between permutations\n#'\n#' Compute the distance between two given permutations. If only one permutation is \n#' given the other one is assumed to be the identity (1,2,3,....,n)\n#' The distance can be kendall, cayley, hamming and ulam\n#'\n#' @param perm1 a permutation\n#' @param perm2 optional a permutation\n#' @param dist.name optional. One of: kendall (default), cayley, hamming, ulam\n#' @return The distance between the permutations \n#' @export\n#' @examples\n#' distance(c(1,2,3,5,4))\n#' distance(c(1,2,3,5,4), c(1,2,3,5,4))\n#' distance(c(1,2,3,5,4), c(1,4,2,3,5), \"cayley\")\ndistance<-function(perm1,perm2=identity.permutation(length(perm1)), dist.name=\"kendall\"){\n  dist <- 0;\n  perm.length<-length(perm1);\n  if(! .same.length.perms(perm1,perm2))\n    stop (\"The permutations must have the same number of items\")\n  dist_id = .check.distance.name(dist.name)\n  if( dist.name == \"Hamming\" || dist.name == \"hamming\" ) {\n    sigma <- .compose.perms(perm1, inverse.permutation(perm2))\n    for(i in 1:perm.length)\n      if (sigma[i] != i ) dist <- dist + 1\n  }else \n    dist<-.C(\"compute_distance\", as.integer(dist_id), as.integer(perm.length), \n             as.integer(perm1), as.integer(perm2), as.integer(dist))[5]\n  return(unlist(dist));\n}\n\n#' Get the maximum value of the distance ebtween permutations\n#'\n#' Compute the maximum posible value for the distance between two given permutations.\n#' The distance can be kendall, cayley, hamming and ulam\n#'\n#' @param perm.length number of items in the permutations\n#' @param dist.name optional. One of: kendall (default), cayley, hamming, ulam\n#' @return The maximum value for the distance between the permutations \n#' @export\n#' @examples\n#' maxi.dist(4,\"cayley\")\n#' maxi.dist(10,\"ulam\")\n#' maxi.dist(4)\nmaxi.dist <- function(perm.length, dist.name=\"kendall\"){\n  dist_id = .check.distance.name(dist.name)\n  if (dist_id == .CAYLEY.DISTANCE || dist_id == .ULAM.DISTANCE ) return (perm.length - 1 )\n  if (dist_id == .HAMMING.DISTANCE ) return ( perm.length )\n  if (dist_id == .KENDALL.DISTANCE ) return ( perm.length * ( perm.length - 1 ) / 2 ) \n  return (-1)\n}\n\n#' Count permutations at a distance\n#'\n#' Given a distance (kendall, cayley, hamming or ulam), \n#' the number of items in the permutations and distance value d, \n#' how many permutations are there at distance d from any permutation?\n#'\n#' @param perm.length number of items in the permutations\n#' @param dist.value the distance\n#' @param dist.name optional. One of: kendall (default), cayley, hamming, ulam\n#' @param disk optional can only be true if counting the permutations at each Ulam distance.\n#' Insted of generating the whole set of SYT and count of permutations per distance, it loads the info from a file in the disk\n#' @return The number of permutations at the given distance\n#' @export\n#' @examples\n#' count.perms.distance(4,2,\"kendall\")\n#' count.perms.distance(4,2,\"ulam\")\n#' count.perms.distance(4,2,\"hamming\")\n#' count.perms.distance(4,2,\"cayley\")\ncount.perms.distance <- function(perm.length, dist.value, dist.name=\"kendall\", disk=FALSE){\n  if (dist.value < 0 ) stop(\"The distance must greater than or equal to 0\")\n  count <- 0\n  dist_id = .check.distance.name(dist.name)\n  if ( disk ){\n    if (dist_id == 3){\n      dist_id = 4\n      if ( ! file.exists(paste('permus_per_dist_',perm.length, sep=\"\")) )\n        stop(\"Generate first the files. Try: \",paste ('generate.aux.files(',perm.length, ')'))\n    }\n    else stop (\"Counting form disk can only be used with Ulam distance\")\n  }\n  count <- .C(\"count_permus_at_dist\", as.integer(dist_id), as.integer(perm.length),as.integer( dist.value ),as.double(count))[4]\n  return (count[[1]]) ## = unlist(count) \n}\n\n#' Count permutations with at least a given number of unfixed points\n#'\n#' Given the number of items in the permutations and the number of unfixed points u, \n#' how many permutations are there with at least u unfixed points?\n#'\n#' @param perm.length number of items in the permutations\n#' @param unfixed optional the number of unfixed points\n#' @return The number of permutations in which the number of \n#' unfixed points is greater than or equal to the specified argument\n#' @export\n#' @examples\n#' count.perms.unfixed.points.gtet(4,1)\ncount.perms.unfixed.points.gtet <- function(perm.length, unfixed=perm.length){\n  #function g(n,k) in paper..\n  #count the num of perms in which the first k positions have sigma(i)!=i, for all 0<i<=k\n  #the rest can be 0 or 1\n  #if(k=perm.length) counts the number of derangements\n  if (unfixed < 0 || unfixed > perm.length) stop(\"The number of unfixed items must be between 0 and \", perm.length)\n  res <- 0\n  res <- .C(\"count_permus_with_at_least_k_unfixed_points\", as.integer(perm.length), as.integer(unfixed), as.double(res))[3];\n  return(res[[1]])\n}\n\n#' Count permutations with a given number of fixed points\n#'\n#' Given the number of items in the permutations and the number of fixed points f, \n#' how many permutations are there with f fixed points?\n#'\n#' @param perm.length number of items in the permutations\n#' @param fixed the number of fixed points\n#' @return The number of permutations in which the number of \n#' fixed points is equal to the specified argument\n#' @export\n#' @examples\n#' count.perms.fixed.points(4,1)\ncount.perms.fixed.points <- function(perm.length, fixed){\n  return (count.perms.distance(perm.length, perm.length - fixed, \"hamming\"))\n}\n\n#' Count derangements\n#'\n#' Given the number of items in the permutations,\n#' how many permutations are there with no fixed point?\n#'\n#' @param perm.length number of items in the permutations\n#' @return The number of derangements of the specified length\n#' @export\n#' @examples\n#' count.derangements(4)\ncount.derangements <- function(perm.length){\n  return(count.perms.distance(perm.length, perm.length, \"hamming\"))\n}\n\n#' Count permutations with a given number of cycles\n#'\n#' Given the number of items in the permutations,\n#' how many permutations are there with with the given number of cycles?\n#'\n#' @param perm.length number of items in the permutations\n#' @param num.cycles number of cycles of the permutations to count\n#' @return The number of permutations with the specified number of cycles\n#' @export\n#' @examples\n#' count.perms.cycles(4,2)\n#' count.perms.cycles(4,1)\ncount.perms.cycles <- function(perm.length,num.cycles){\n  return(count.perms.distance (perm.length , perm.length - num.cycles, \"cayley\"))\n}\n\n#' Generate a collection of permutations with a given number of cycles\n#'\n#' Given a number of permutations, the number of items in the permutations\n#' and number of cycles, generate a sample of permutations with the specified length \n#' and number of cycles\n#'\n#' @param n number of permutations in the sample\n#' @param perm.length number of items in the permutations\n#' @param cycles number of cycles\n#' @return A sample of permutations with the specified length \n#' and number of cycles\n#' @export\n#' @examples\n#' r.perms.cycles(1, 4, 2)\nr.perms.cycles <- function(n, perm.length, cycles){\n  if (cycles > perm.length ) \n    stop (\"The number of cycles must be smaller\n        than the number of items in the permutations, perm.length\")\n  return(r.dist.d(n, perm.length, perm.length - cycles, \"cayley\"))\n}\n\n#' Generate a collection of derangements\n#'\n#' Given a number of permutations and the number of items in the permutations\n#' generate a sample of permutations with the specified length \n#' and no fixed point\n#'\n#' @param n number of permutations in the sample\n#' @param perm.length number of items in the permutations\n#' @return A sample of permutations with the specified length \n#' and number of cycles\n#' @export\n#' @examples\n#' r.perms.cycles(1, 4, 2)\nr.derangement <- function(n, perm.length){\n  return(r.dist.d(n, perm.length, perm.length, \"hamming\"))\n}\n\n#' Generate a collection of permutations at a given distance\n#'\n#' Given a number of permutations, the number of items in the permutations,\n#' a distance value and a distance name, generate a sample of permutations with \n#' the specified length at the given distance\n#'\n#' @param n number of permutations in the sample\n#' @param perm.length number of items in the permutations\n#' @param dist.value distance value\n#' @param dist.name distance name. One of: kendall (default), cayley, hamming, ulam\n#' @return A sample of permutations at the given distance\n#' @export\n#' @examples\n#' r.dist.d(1, 4, 2, \"ulam\")\nr.dist.d <- function(n, perm.length, dist.value, dist.name=\"kendall\"){\n  num.perms <- n\n  dist_id = .check.distance.name(dist.name)\n  if ( dist.value < 0 ) stop(\"The distance must be greater than 0\")\n  if ( dist.value > maxi.dist(perm.length,dist.name) )\n    stop(\"The distance must be smaller than the largest\n         possible \",dist.name,\" distance for permutations of \",perm.length,\n          \" items, which is \",maxi.dist(perm.length, dist.name))\n  if (dist_id == .HAMMING.DISTANCE && dist.value == 1 ) return (0)\n  res<-.Call(\"get_random_sample_at_dist_d\", as.integer(dist_id), \n             as.integer(perm.length),as.integer(num.perms),as.integer( dist.value ))\n  return(res)\n}\n\n#' Get the decomposition vector\n#'\n#' Given a permutation and a distance name generate the decomposition vector \n#'\n#' @param perm the permutation\n#' @param dist.name optional the name of the distance. One of: kendall (default), cayley, hamming\n#' @return The distance decomposition vector of the given permutation and distance\n#' @export\n#' @examples\n#' permutation2decomposition(c(1,2,4,3,5), \"kendall\")\n#' permutation2decomposition(c(1,2,4,3,5), \"cayley\")\n#' permutation2decomposition(c(1,2,4,3,5), \"hamming\")\npermutation2decomposition <- function(perm, dist.name=\"kendall\"){\n  if (!.is.permutation.one(perm)) stop(\"The input parameter perm must be a valid permutation\")\n  perm.length<-length(perm)\n  dist_id = .check.distance.name(dist.name, TRUE)\n  if (dist_id == .HAMMING.DISTANCE) {\n    vec <- rep(0,perm.length)\n    for (i in 1:perm.length) if (perm[i] != i) vec[i] = 1\n    return(vec)\n  }\n  vec <- c(1:perm.length) #only the first (perm.lenth-1) pos will be returned\n  #the last equals 0\n  res <- .C(\"get_altern_repre_for_permu\", as.integer(dist_id), as.integer(perm.length), \n            as.integer(perm), as.integer(vec))[4]\n  return(unlist(res)[ 1 : perm.length - 1 ] )\n}\n\n#' Get a permutation consistent with a decomposition vector\n#'\n#' Given a distance decomposition vector and a distance name, generate uniformly at random \n#' a permutation consistent with the decomposition vector. \n#'\n#' @param vec the permutation\n#' @param dist.name optional the name of the distance. One of: kendall (default), cayley, hamming\n#' @return The distance decomposition vector of the given permutation and distance\n#' @export\n#' @examples\n#' decomposition2permutation(c(1,0,1,0,0), \"kendall\")\n#' decomposition2permutation(c(1,0,1,0,0), \"cayley\")\n#' decomposition2permutation(c(1,0,1,0,0), \"hamming\")\ndecomposition2permutation <- function(vec, dist.name=\"kendall\"){\n  dist_id = .check.distance.name(dist.name, TRUE)\n  if (dist_id == .CAYLEY.DISTANCE || dist_id == .HAMMING.DISTANCE )\n    if (any(sapply(X = vec, function(x){(x!=0 && x !=1) })))\n      stop(\"The input vector does not correspond to a valid permutation, must be binary\")\n  if(dist_id == .KENDALL.DISTANCE \n     && any(sapply(X = 1:length(vec), function(x){(vec[x] < 0 ||vec[x] > length(vec)-x) })))\n    stop(\"The input vector does not correspond to a valid permutation\")\n  perm.length <- length(vec) \n  if (dist_id == 0 || dist_id == 1) {\n    perm.length = perm.length + 1\n    vec[ perm.length ] = 0 \n  }\n  sigma <- rep(0,perm.length)\n  sigma <- .C(\"get_permu_given_altern_repre\", as.integer(dist_id), \n              as.integer(perm.length), as.integer(vec), as.integer(sigma))[4]\n  return(unlist(sigma))\n}\n\n###################   DATASET   ###################\n#' @name perm.sample.med\n#' @docType data\n#' @title Sample of permutations\n#' @description\n#' A rda file containing a sample of permutations\n#' @format\n#' Each row is a permtuation\nNULL\n#' @name perm.sample.small\n#' @docType data\n#' @title Sample of permutations\n#' @description\n#' A rda file containing a sample of permutations\n#' @format\n#' Each row is a permtuation\nNULL\n#' @name data.apa\n#' @docType data\n#' @title Sample of permutations APA\n#' @description\n#' A rda file containing a sample of permutations of the American Psychology Association\n#' @format\n#' Each row is a permtuation\nNULL\n#' @name data.order\n#' @docType data\n#' @title Sample of permutations\n#' @description\n#' A rda file containing a sample of permutations\n#' @format\n#' Each row is a permtuation\nNULL\n",
    "created" : 1404206859097.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1780033225",
    "id" : "4E6FEDFB",
    "lastKnownWriteTime" : 1422286490,
    "path" : "~/Dropbox/permus/prj/R/PerMallows/R/PerMallows.R",
    "project_path" : "R/PerMallows.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}