{
    "contents" : "\\documentclass[article]{jss}%\\documentclass{article}\n\\usepackage{amsmath}\n\\begin{document}\n\\SweaveOpts{concordance=TRUE}\n\\SweaveOpts{keep.source=FALSE}\n\n\n<<echo=false>>=\nlibrary(PerMallows)\n#options(prompt = \" \", continue = \" \")\noptions(prompt = \"R> \")\n@\n\nIn this section we show how to use the \\pkg{PerMallows} package. \\pkg{PerMallows} includes functions to generate permutations, as well as the most common operators and distance related functions. The metrics considered are Kendall's-$\\tau$, Cayley, Hamming and Ulam. Moreover, \\pkg{PerMallows} implements the algorithms for probability distributions introduced in \\cite{Irurozki2014,Irurozki2014a,Irurozki2014b}. The probability models considered are Mallows (MM) and Generalized Mallows (GMM).\n\nThe number of items in the permutations, $n$, is denoted \\code{perm.length} in \\pkg{PerMallows}.\n\n\\subsection{Permutations}\n\\paragraph*{Generation}\nThe most basic function consists of generating permutations. The permutations are coded as vectors of the first $n$ natural numbers where each item appears once and once only. They can be defined by hand as follows:\n<<echo=true>>=\nsigma <- c(1,5,6,4,2,3)\nsigma\n@\n\nThe validity of a vector as a permutation can be checked with the function \\code{is.permutation}.\n<<echo=true>>=\nis.permutation(perm=sigma)\nis.permutation(c(0,1,5,4,2,3))\nis.permutation(c(1,8,9,2,5,3))\n@\n\nThe identity permutation is that which maps every item $i$ to position $i$. It can be created with the \\code{identity.permutation} function.\n<<echo=true>>=\nidentity.permutation(perm.length=6)\n@\nThe generation of a permutation uniformly at random is supported via the \\code{runif.permutation} function. \n<<echo=true>>=\nrunif.permutation(n=2,perm.length=6)\n@\n\n\nThe generation of the set of every possible permutation of $n$ items is carried out with the \\code{permutations.of} function. Recall that the number of permutations of $n$ items increases factorially with $n$ and it is thus computationally expensive to generate every permutation of $n \\ge 10$. By default, the \\code{alert} argument is set to true. When \\code{alert} is \\code{TRUE} and $n$ is greater than 9, an alert message is shown. \n<<echo=true>>=\npermutations.of(perm.length=3, alert=FALSE)\npermutations.of(perm.length=10)\n@\n\nThe collection of permutations generated is stored as a 2-dimensional matrix. It is also possible to read such a matrix from disk using the function \\code{read.permutation.file}, which also checks if every row is a valid permutation. \n<<echo=true>>=\npath = system.file(\"test.txt\", package='PerMallows')\nsample = read.permutation.file(path)\n@\n\nTogether with the \\pkg{PerMallows} package, we provide some small datasets that will be used as running examples throughout this reference manual. \n<<echo=true>>=\ndata('perm.sample.small')\nperm.sample.small\n@\n\nAnother way of generating permutations is by ranking the ratings of a set of items. Suppose we have the results of five students in three different tests. An example of such a file is given in 'data.order'. After reading the file, we can get the ranks of each student with the function \\code{order.ratings}.\n\n<<echo=true>>=\ndata('data.order')\ndata.order\norder.ratings(ratings=data.order)\n@\n\n\\paragraph*{Operations} \nTwo permutations can be composed and the result is a permutation. \n<<echo=true>>=\nsigma <- c(1,5,6,4,2,3)\npi <- c(3,5,1,2,6,4)\ncompose(perm1=sigma, perm2=pi)\n@\n\nBe aware that the composition is not commutative. \n<<echo=true>>=\ncompose(perm1=sigma, perm2=pi)\ncompose(perm1=pi, perm2=sigma)\n@\n\nOur implementation of the composition allows one of the arguments to be a collection of permutations. In this case, every permutation in the sample is composed with the permutation in the other argument, resulting in a new collection of permutations. \n<<echo = true>>=\ntau <- c(2,1,3,4)\ncompose(perm1=perm.sample.small,perm2=tau)\n@\n\nA useful summary of a sample is given by the number of permutations in the sample in which item $i$ appears at position $j$. This is usually denoted as the frequency matrix or first order marginal matrix. The current package supports it via the \\code{freq.matrix} function. The parameter \\code{perm} can be either a sample of permutations or a single permutation. Note that the frequency matrix of a single permutation, which is usually denoted permutation matrix, is an alternative representation of a permutation. We will illustrate the \\code{freq.matrix} function using the well known APA dataset. \n \nThe American Psychological Association (APA) dataset includes 15449 ballots of the election for the president in 1980. Each voter ranked at least one of the five candidates. Along with this package we distribute the 5738 ballots that ranked all the five candidates under the name of \\code{data.apa}. Its marginal matrix is computed as follows: \\label{code:freq_apa}\n<<echo=true>>= \ndata('data.apa')\nfreq.matrix(perm=data.apa)\n@ \n\nUnder the ranking interpretation, $\\sigma(i)=j$ denotes that item $i$ is ranked at position $j$. It follows that the first column counts the proportion of the votes in which each candidate was ranked as the favorite. We can see that the thrid candidate was chosen as the best alternative by the majority of the voters and thus won the election. This dataset has been largely used in the literature. In particular, one can find in \\cite{diaconis1989} a spectral analysis that takes into account the first order marginal of the dataset.\n\nAnother basic operation for permutations is inversion. The inverse of a permutation can be obtained using the function \\code{inverse.permutation}.\n<<echo=true>>=\ninverse.permutation(perm=sigma)\n@\n\nThe argument \\code{perm} can be a single permutation or a collection of permutations. It is worth noting that the inverse of the inverse of any permutation is itself.\n<<echo=true>>=\ninverse.permutation(inverse.permutation(c(1,4,5,3,2)))\n@\n\nThe present package also includes operators for the manipulation of permutations. The \\code{swap} function, for example, swaps two prescribed items. \n<<echo=true>>=\nswap(perm=identity.permutation(6),i=1,j=3)\n@\n\nThe \\code{insert.at} function takes an item from position $i$ and inserts it after position $j$. \n<<echo=true>>=\ninsert.at(perm=identity.permutation(6), i=5, j=2)\n@\n\nAn inversion at position $1 \\leq i < n$ occurs when the items at positions $i$ and $i+1$ are swapped. \n<<echo=true>>=\ninversion.at(perm=identity.permutation(6), i=1)\n@\n\n\\paragraph*{Distances}\nWe will now show how to deal with functions related with the distances between permutations included in this package. These functions include the argument \\code{dist.name} which, unless otherwise stated, is one of the following: \\code{kendall}, \\code{cayley}, \\code{hamming} or \\code{ulam}. Moreover, its default value is \\code{kendall}.\n\nThe following computes the distance between \\code{perm1} and \\code{perm2} for a given metric. \n<<echo=true>>=\npi\nsigma\ndistance(perm1=sigma, perm2=pi, dist.name='cayley')\n@\n\nThe arguments \\code{perm2} and \\code{dist.name} can be omitted. In that case, \\code{perm2} is assumed to be the identity, that means that the following code computes the Kendall's-$\\tau$ distance between \\code{pi} and the identity permutation.\n<<echo=true>>=\ndistance(perm1=pi)\n@\n\nAs we have seen, the Kendall's-$\\tau$, Cayley and Hamming distances from a permutation to the identity can be decomposed in a vector. Clearly, this decomposition is different regarding the metric in question. In particular, the decomposition of the Kendall's-$\\tau$ distance is a vector of $n$$-1$ integer terms, while for the Cayley distance it is a binary vector of $n-1$ terms and for the Hamming distance it is a binary vector of $n$ terms. These decompositions are computed by the following function:\n<<echo=true>>=\nsigma\nv.vector <- permutation2decomposition(perm=sigma, dist.name='kendall')\nv.vector\nx.vector <- permutation2decomposition(perm=sigma, dist.name='cayley')\nx.vector\nh.vector <- permutation2decomposition(perm=sigma, dist.name='hamming')\nh.vector\n@\n\nGiven that there are possibly many longest increasing subsequences in a permutation, there is no decomposition of the Ulam distance. The possible values for the \\code{dist.name} are therefore, \\code{kendall}, \\code{cayley} and \\code{hamming} and the default value being \\code{kendall}. \n\nThe \\pkg{PerMallows} package can also perform the inverse operation, that is, given a decomposition vector and a metric, obtain a permutation consistent with the vector. Recall that for Cayley and Hamming there are possibly many permutations with a particular decomposition. In these situations, the following function recovers uniformly at random one of the permutations consistent with the decomposition vector.\n<<echo=true>>=\ndecomposition2permutation(vec=v.vector, dist.name='kendall')\ndecomposition2permutation(vec=x.vector, dist.name='cayley')\ndecomposition2permutation(vec=h.vector, dist.name='hamming')\n@\n\nThe \\pkg{PerMallows} package implements a function to obtain the list of the cycles in which the permutation decomposes. \n<<echo=true>>=\ncycles <- permutation2cycles(perm=sigma)\n@\n\nThe \\code{cycle2str} function can be used in order to friendly display the cycles.\n<<echo=true>>=\ncycle2str(cycles)\n@\n\nAlso, the inverse operation, consisting of building a permutation given the list of cycles, is supported. \n<<echo=true>>=\ncycles2permutation(cycles=cycles)\n@\n\n\\pkg{PerMallows} includes a function to count the number of permutations of $n$ items at distance \\code{dist.value} for a given distance.\n<<echo=true>>=\ncount.perms.distance(perm.length=6,dist.value=2,dist.name='ulam')\n@\n\nThe most computationally expensive version of any function is usually that concerning the Ulam distance. In the case where one expects to work repeatedly with a model under the Ulam distance of a particular \\code{perm.length} number of items (being \\code{perm.length} large, say \\code{perm.length } $>50$), it is a good idea to generate auxiliary files including the count of permutations at each distance and later operating with those files. The operations that can be accelerated are counting and generating random permutations, learning and sampling. The files are generated with the following function:\n\n<<echo=true>>=\ngenerate.aux.files( perm.length=6 )\n@\n\nThe fastest version of the function to count the number of permutations at a given Ulam distance is the same as the one above but the optional parameter \\code{disk} is set to \\code{TRUE}. In this version, the data is read from the files instead of computing it.  \n\n<<echo=true>>=\ncount.perms.distance(perm.length=6, dist.value=4, dist.name='ulam', disk=TRUE)\n@\n\nRegarding the process of counting permutations under the Cayley distance, we also include a function to count the number of permutations with \\code{perm.length} items and \\code{num.cycles} cycles. \n<<echo=true>>=\ncount.perms.cycles(perm.length=6,num.cycles=4)\n@\n\nThe following functions are related to the Hamming distance. Recall that an unfixed point is  a position of the permutation $\\sigma$ such that $\\sigma(i) \\neq i$, while a fixed point is a position such that  $\\sigma(i) =i$. A derangement is a permutation with no fixed point. \\pkg{PerMallows} includes functions to count the number of permutations of \\code{perm.length} items with exactly \\code{fixed} fixed points, to count the number of permutations with at least \\code{unfixed} unfixed points and to count the number of permutations with no fixed points. \n<<echo=true>>=\ncount.perms.fixed.points(perm.length=6, fixed=4)\ncount.perms.unfixed.points.gtet(perm.length=6, unfixed=2)\ncount.derangements(perm.length=6)\n@\n\nThe generation of random permutations at a prescribed distance is supported by the \\code{r.dist.d} function, which generates \\code{n} permutations of \\code{perm.length} items at distance \\code{dist.value} for a particular metric.\n<<echo=true>>=\nr.dist.d(n=4, perm.length=5,dist.value=3,dist.name='ulam')\n@\n\nRegarding the Cayley distance, the \\code{r.perms.cycles} function generates uniformly at random permutations of \\code{perm.length} items with \\code{cycles} cycles. \n<<echo=true>>=\nr.perms.cycles(n=3, perm.length=6,cycles=5)\n@\n\nSimilarly, \\code{r.derangement} generates \\code{n} permutations with no fixed point. \n<<echo=true>>=\nr.derangement(n=5, perm.length=6)\n@\n\\subsection{Distributions on permutations}\nIn this section we show how to deal with the Mallows and Generalized Mallows models. We show functions for inference, learning and sampling both models.\n\nBear in mind that Mallows model (MM) can be used with every metric for permutation considered in this manuscript (Kendall's-$\\tau$, Cayley, Hamming and Ulam). On the other hand, the Generalized Mallows model (GMM) can only be used with Kendall's-$\\tau$, Cayley and Hamming\\footnote{Although strictly speaking the GMM can not be used with the Hamming distance, we denote the similar Weighted Hamming Mallows model as GMM for the sake of clarity.}. Remember that for distributions on permutations of \\code{perm.length} items, the dispersion parameter vector $\\boldsymbol \\theta$ has \\code{perm.length}-1 terms when the distance is either Kendall's-$\\tau$ or Cayley, and \\code{perm.length} when the distance is Hamming.\n\n\\paragraph*{Parameter fitting, known mode}\nGiven a sample and a guess for the central permutation, the following two functions can obtain the dispersion parameters. The first one, \\code{lmm.theta}, deals with the MM while \\code{lgmm.theta} returns the vector of dispersion parameters of the GMM. \n<<echo = true>>=\ndata('perm.sample.med')\nlmm.theta(sample=perm.sample.med , sigma_0= identity.permutation(6), dist.name = 'ulam', disk=TRUE)\nlgmm.theta(sample=perm.sample.med , sigma_0 = c(2,1,6,5,3,4))\n@\n\n\\paragraph*{Parameter fitting, unknown mode}\nThe estimation of the parameters of the MM and GMM is done with separate functions, \\code{lmm} and \\code{lgmm} respectively. Both need the sample to fit as arguments. The metric to use, an initial guess for the consensus permutation and the estimation methods are optional methods. The latter argument can be \\code{approx} (by default) for the approximate learning and \\code{exact} for the exhaustive one. \n<<echo = true>>=\nmy.mm <- lmm (sample=perm.sample.med , sigma_0_ini= identity.permutation(6), dist.name = 'cayley', estimation = 'exact')\nmy.gmm<- lgmm(sample=perm.sample.med , sigma_0_ini = c(2,1,6,5,3,4), dist.name = 'cayley', estimation = 'approx')\nmy.mm\nmy.gmm\n@\n\nIt is worth noticing that both methods obtain the same estimator for the central permutation. If the auxiliary files have been generated with the function \\code{generate.aux.files}, learning the parameters of the models under the Ulam distance can be done by reading the files instead of computing the necessary data. \n<<echo = true>>=\nlmm(sample=perm.sample.med, dist.name='ulam', disk=TRUE)\n@\n\nThe most natural distance for ranking data is the Kendall's-$\\tau$ and, consequently, the distance-based probability models for voting data are based on the same distance. The GMM under the Kendall's-$\\tau$ distance can be used to model the APA dataset as follows:\n<<echo=true>>=\nlgmm(data.apa)\n@\n\nThe central permutation $\\sigma_0$ is understood as the average ranking, so the reader can see that candidate 3 was ranked, on average, at position 2. Recall that we have said that candidate 3 won the election in previous lines. For the understanding of this apparent incongruence we must carefully look at the data. \n\nCandidate 3 won the election because he was ranked as the first option for the majority of voters. However, it was also ranked as the least favorite by a big proportion of voters, as it can be noted by looking at the frequency matrix of the APA dataset in page~\\pageref{code:freq_apa}. As a result, on average, it was ranked in second position. \n\nThe Hamming distance, which is related to fixed points, is the natural metric for measuring matchings. Let us analyze a dataset with the GMM under the Hamming distance. \n<<echo = true>>=\nlgmm(perm.sample.med,dist.name='hamming')\n@\n\nNote that the central permutation, that which maximizes the number of fixed points, is given by the identity. Taking into consideration the dispersion parameters, which are a measure of spread, we can analyze how strong the consensus is. For example, the reader can note that $\\theta_1$ is the largest spread parameter. This means that the consensus at the first position is large in comparison the rest and thus a large number of permutations in the sample will fix position 1. On the contrary, $\\theta_3$ is the smallest, although it is greater than zero. This means that the probability of fixing position 3 is greater than $1/n$ but the consensus is weak. \n\n\\paragraph*{Generating from the model}\nAlthough there are two separate functions for sampling MM and GMM (\\code{rmm} and \\code{rgmm}), they are used in a similar way. The required arguments for the MM (GMM) are the number of permutations to be generated, \\code{n}, the parameters of the distribution, that is $\\sigma_0$ and $\\theta$ ($\\boldsymbol\\theta$), the name of the distance used and the sampling algorithm (\\code{distances}, \\code{multistage} or \\code{gibbs}).\n<<echo=true>>=\nrmm (n=5, sigma0=my.mm$mode,  theta=my.mm$theta,  dist.name='kendall', sampling.method='distances')\nrgmm(n=5, sigma0=my.gmm$mode, theta=my.gmm$theta, dist.name='kendall', sampling.method='multistage')\n@\n\nIf the auxiliary files have been generated with the function \\code{generate.aux.files}, the Distances sampling for the Ulam distance can rely on those files by setting the \\code{disk} parameter to \\code{TRUE}.\n\n<<echo=true>>=\nrmm(n=3, sigma0=identity.permutation(6), theta=1, dist.name='ulam',disk=TRUE)\n@\n\n\\paragraph*{Probability}\nThe probability of a permutation for a given MM (GMM) is calculated with the \\code{dmm} (\\code{dgmm}) function. The arguments of \\code{dmm} (\\code{dgmm}) are the permutation, the consensus permutation $\\sigma_0$, dispersion parameter $\\theta$ ($\\boldsymbol \\theta$) and the name of the distance used, which by default is Kendall's-$\\tau$.\n<<echo=true>>=\ndmm(perm=my.mm$mode, sigma0=my.mm$mode, theta=my.mm$theta, dist.name='ulam')\ndmm(perm=sigma,      sigma0=my.mm$mode, theta=my.mm$theta, dist.name='hamming')\n\ndgmm(perm=my.gmm$mode, sigma0=my.gmm$mode, theta=my.gmm$theta, dist.name='kendall')\ndgmm(perm=sigma,       sigma0=my.gmm$mode, theta=my.gmm$theta, dist.name='kendall')\n@\n\nIn the following lines we summarize the previous functions using the APA dataset. The MLE for the model parameters are first estimated with the \\code{lmm} (resp. \\code{lgmm}) function for the MM (resp. GMM) under the Kendall's-$\\tau$ distance and are denoted as \\code{apa.mm} (resp. \\code{apa.gmm}). The log-likelihood is computed as follows. \n<<echo=true>>=\napa.mm <- lmm(data.apa)\nlog.prob <- apply(data.apa, MARGIN=1, FUN=function(x){log(dmm(x,apa.mm$mode, apa.mm$theta))})\nsum(log.prob)\napa.gmm <- lgmm(data.apa)\nlog.prob <- apply(data.apa, MARGIN=1, FUN=function(x){log(dgmm(x,apa.gmm$mode, apa.gmm$theta))})\nsum(log.prob)\n@\nNote that the log-likelihood of the MLE for the GMM, with $n$ parameters, fits slightly better the APA dataset than its particularization with two parameters, the MM. \n\n\\pkg{PerMallows} includes the computation of the marginal distribution for both MM and GMM under the Hamming distance. The set of fixed and unfixed points is represented in the distance decomposition vector, so $H_j(\\sigma)=0$ means that $j$ is a fixed point,  $H_j(\\sigma)=1$ that $j$ is an unfixed point and \\code{NA} means that $j$ is unknown. The following command computes the marginal distribution of those permutations having fixed points at positions 2 and 4 and unfixed points at position 1. \n\n<<echo=true>>=\nmarginal(h=c(1,0,NA,0,NA), theta= c(1.1,2,1,0.2,0.4))\n@\n\n\\pkg{PerMallows} includes functions to compute the expectation of the distance (resp. its decomposition vector) under the MM (resp.  GMM) under the Hamming distance. The former computes the expectation of the distance under an MM of a given dispersion parameter and number of items. The latter, computes the expectation of the distance decomposition vector given a multidimensional dispersion parameter. \n<<echo=true>>=\nexpectation.mm(theta=3,perm.length=9,'ulam')\nexpectation.gmm(c(1.1,2,1,0.2,0.4),'cayley')\n@\n\n%\\bibliographystyle{plain}\n\\bibliography{../../mendeley}\n\n\\end{document}",
    "created" : 1405529877230.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3615670537",
    "id" : "71EAAA31",
    "lastKnownWriteTime" : 1410611516,
    "path" : "~/Dropbox/permus/tex/drafts/R_package_JStatSW/manual-sweave.rnw",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "sweave"
}